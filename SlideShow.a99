* New slideshow
*
* Supported types:
*
* TI Artist+ - P,C - 12288 - 6144,6144
* Mono TIAP (no color table) - P - 6144 - 6144
* Half multicolor - P,C,M - 14336 - 6144,6144,2048
* paletted bitmap - P,C,M - 12320 - 6144,6144,32
* scanline paletted bitmap - 18432 - 6144,6144,6144
*
* Supports a roughly unlimited number of images by 
* we just use a disk directory... maybe disk after disk.
* Random play could be a directory seek... but how would we determine
* which disk? Maybe just count through it anyway. That might get messy
* for modulo though. To that end, maybe at least count how many pics
* we have. If we skip out on Multicolor (no need to keep that), then
* we can just count 'P' files.
*
* Otherwise, we can Id the file type by just loading the M file
* first: 0 bytes = TIAP, 2048 bytes = half mult, 
* 32 bytes = pal bmp, 6144 bytes=scanline bitmap
*
* Updated to unlock and relock properly on F18A 1.6, but not tested yet.
*
* I won't explicitly support subdirectories, but you could do so by entering
* the longer path as your device name. Thus the longer than 8 char devices.
*
* One nice thing is I can probably reuse some of this for my music player...
* just define the ROM as yet another file device. I don't think I'll do that here.
*

	DEF START,SFIRST,SLAST,SLOAD
	
*	AORG >2100

* VDP address for the palette GPU program
PROGLD EQU >1B20

* VDP Address for PABs
PABADR EQU >1D00

* VDP hardware (not used consistently)
VDPRD	EQU >8800
VDPST EQU >8802
VDPWD EQU >8C00
VDPWADR EQU >8C02

SLOAD
SFIRST
	B @START
	
COUNT1 DATA >0001
COUNT2 DATA >0001
COUNT3 DATA >0001
COUNT4 DATA >0001
COUNT5 DATA >0001
COUNT6 DATA >0001
VDPBAD DATA >0000
DSRDAT DATA >2EAA

*****
**
* BL @FILES
*
* We need to implement a CALL FILES(1) before use to make loading work better
* That puts the top of VRAM at >3BDB. With that there, we can load everything
* except per-scanline paletted images without conflicting with the disk system.
* For those, we can backup the disk buffers as they are only 1061 bytes
*
* Set max number of open files to 1 (by asmusr, adapted by Tursi) 
********************************************************************************
FILES   MOV  R11,@SAVE
        LI   R0,PABADR
        LI   R1,>0116                  ; length (1) and subprogram >16
        BL   @V2BW                     ; Copy 2 bytes from PDATA (RAM) to PAB (VRAM)
        LI   R0,PABADR
        MOV  R0,@>8356                 ; Point to subroutine in DSR
        LI   R0,>0100                  ; 1 files
        MOVB R0,@>834C                 ; #files argument for subroutine 016h
        BLWP @DSRLNK                   ; Call DSR with subprogram option
        DATA 10
*       Return
        MOV  @SAVE,R11
        B    *R11

**
* WRAPLOAD - wraps an EA#5 load operation
* Maximum file size is 6k (>1800 bytes)
* R0 - VDP Address
* R1 - pointer to filename (~ terminated)
* build a PAB
WRAPLOAD
	LI R2,pab
	li r3,>0500			* LOAD, no error
	mov r3,*r2+
	mov r0,*r2+			* VDP buffer address
	clr r3
	mov r3,*r2+			* record length, char count (not used for LOAD)
	li r3,>1802			* maximum data size (6k +2 bytes to work around DSR bug)
	mov r3,*r2+
	jmp wrapdsr
	
**
* WRAPOPENLONG - wraps a DSR OPEN for long filenames
* R1 - pointer to filename (~ terminated)
* build a PAB
WRAPOPENLONG
	LI R2,pab
	LI R3,>001c			* OPEN, variable, internal, input, sequential
OPENCOMMON	
	mov r3,*r2+
	clr r3					* no buffer needed
	mov r3,*r2+		
	mov r3,*r2+			* DSR to provide record length
	mov r3,*r2+			* first record
	jmp wrapdsr
	
**
* WRAPOPENSHORT - wraps a DSR OPEN for short filenames
* R1 - pointer to filename (~ terminated)
* build a PAB
WRAPOPENSHORT
	LI R2,pab
	LI R3,>000c			* OPEN, fixed, internal, input, sequential
	JMP OPENCOMMON

**
* WRAPCLOSE - wraps a DSR CLOSE
* R1 - pointer to filename (~ terminated)
* build a PAB
WRAPCLOSE
	LI R2,pab
	LI R3,>0001			* CLOSE (in LSB)
	SOCB @RECMODE,R3	* get the opened record mode
	SWPB R3
	JMP OPENCOMMON
	
**
* WRAPREAD - wraps a DSR READ on an open file
* max read length is 256 bytes
* R0 - VDP Address
* R1 - pointer to filename (~ terminated)
* build a PAB
WRAPREAD
	LI R2,pab
	LI R3,>0002			* READ (in LSB)
	SOCB @RECMODE,R3	* get the opened record mode
	SWPB R3
	mov r3,*r2+
	mov r0,*r2+			* vdp buffer address
	clr r3
	movb @RECLEN,R3		* note, on variable length data this returns actual bytes
	mov r3,*r2+		
	mov @DSRREC,*r2+ * record number
	jmp wrapdsr

**
* WRAPDSR (jumped to from above wrappers)
* R1 - pointer to filename ('~' terminated)
* R2 - pointer to CPU copy of PAB's 'bias' byte
WRAPDSR
	MOV R11,@SAVE2		* save return address
* get filename length
	mov r1,r0
	li r3,>7e00				* '~'
WDLP1
	cb *r0+,r3
	JNE WDLP1
	s r1,r0						* get diff
	dec r0
	mov r0,*r2+				* and store in DSR buffer (bias 0 and length)
	MOV R0,R2					* get name length
	LI R0,PABADR+10		* filename location in VDP, R1 already set
	BL @VMBW					* write the filename
	LI R0,PABADR
	LI R1,PAB
	LI R2,10
	BL @VMBW					* write the PAB header
	
	MOVB @>837C,R0
	ANDI R0,>D000			* clear 'COND'
	movb r0,@>837c

	LI R0,PABADR+9		* point to PAB name length byte
	MOV R0,@>8356
	BLWP @DSRLNK
	DATA 8
	
	CLR @DSRERR
	MOVB @>837C,R0		* check 'cond'
	ANDI R0,>2000			* if set, bad device name, we'll make that error 255
	JEQ WDJP1
	SETO @DSRERR
WDJP1

	LI R0,PABADR
	LI R1,PAB
	LI R2,9
	BL @VMBR					* read the PAB back in to get any updates
	CLR R0
	MOVB @PAB+1,R0		* both error and mode bits in here
	MOV R0,R1
	ANDI R0,>1F00			* mode bits
	MOVB R0,@RECMODE

	SRL R1,5					* error bits (user was supposed to clear them)
	MOVB R1,@DSRERR		* already FF if the value is zero
WDJP3
		
	MOVB @PAB,R0			* check if opcode was open (0)
	JNE WDJP4
	MOVB @PAB+4,@RECLEN	* save the record length (only if it was OPEN, else it is the count of data)
WDJP4
	MOV @PAB+6,@DSRREC	* save the record number

	MOV @SAVE2,R11
	B *R11


*********************************************************************
*
* All-purpose 'DSRLNK'
*
* Found at 
* http://atariage.com/forums/topic/163692-ea-file-access/#entry2071618
*
* This is essentially the same routine used by Editor/Assembler
*
* Useful scratchpad data (see also SAVE vars below for more persistent)
* >8354 - length of device name found
* >8356 - pointer to DSR name length in PAB (input)
* >83D0 - CRU base used
* >83D2 - address of DSR entry used
*

DSRLNK DATA DREGS,DSR1
VSAVE1  EQU >2032       ; CRU address used (2032 in E/A)
VSAVE2  EQU >2034       ; Address of function called (2034)
VSAVE3  EQU >2036       ; Length of device name found (2036)
VSAVE4  EQU >2038       ; Pointer to DSR filename in PAB (2038)
VSAVE5  EQU >203A       ; some sort of call counter...? (203A)
*
HEX20  DATA >2020
HEXAA  DATA >AAAA
PERIOD BYTE '.','.'
H2000  DATA >2000
CYC1   DATA 0
H1300  DATA >1300
 
DSR1   MOV  *R14+,R5
       SZCB @HEX20,R15
       MOV  @>8356,R0
       MOV  R0,R9
       AI R9,>FFF8
       SWPB R0
       MOVB R0,@VDPWADR
       SWPB R0
       MOVB R0,@VDPWADR
       NOP
       MOVB @VDPRD,R1
       MOVB R1,R3
       SRL  R3,>8
       SETO R4
       LI R2,NAMBUF
DLOOP1 INC  R0
       INC  R4
       C  R4,R3
       JEQ  DJUMP1
       SWPB R0
       MOVB R0,@VDPWADR
       SWPB R0
       MOVB R0,@VDPWADR
       NOP
       MOVB @VDPRD,R1
       MOVB R1,*R2+
       CB R1,@PERIOD
       JNE  DLOOP1
DJUMP1 MOV  R4,R4
       JEQ  DJUMP6
       CI R4,>0007
       JGT  DJUMP6
       CLR  @>83D0
       MOV  R4,@>8354
       MOV  R4,@VSAVE3
       INC  R4
       A  R4,@>8356
       MOV  @>8356,@VSAVE4
SROM   LWPI >83E0
       CLR  R1
       MOV  @H2000,@CYC1
       LI R12,>1100
       JMP  DLOOP2
SROM1  LI R12,>0F00
       MOV  @H1300,@CYC1
DLOOP2 MOV  R12,R12
       JEQ  DJUMP2
       SBZ  >00
DJUMP2 AI R12,>0100
       CLR  @>83D0
       CI R12,>2000
       JEQ  SROM1
       C  R12,@CYC1
       JEQ  DJUMP5
       MOV  R12,@>83D0
       SBO  >00
       LI R2,>4000
       CB *R2,@HEXAA
       JNE  DLOOP2
       A  @5*2+DREGS,R2
       JMP  DJUMP3
DLOOP3 MOV  @>83D2,R2
       SBO  >00
DJUMP3 MOV  *R2,R2
       JEQ  DLOOP2
       MOV  R2,@>83D2
       INCT R2
       MOV  *R2+,R9
       MOVB @>8355,R5
       JEQ  DJUMP4
       CB R5,*R2+
       JNE  DLOOP3
       SRL  R5,>8
       LI R6,NAMBUF
DLOOP4 CB *R6+,*R2+
       JNE  DLOOP3
       DEC  R5
       JNE  DLOOP4
DJUMP4 INC  R1
       MOV  R1,@VSAVE5
       MOV  R9,@VSAVE2
       MOV  R12,@VSAVE1
       BL *R9
       JMP  DLOOP3
       SBZ  >00
       LWPI DREGS
       MOV  R9,R0
       SWPB R0
       MOVB R0,@VDPWADR
       SWPB R0
       MOVB R0,@VDPWADR
       NOP
       MOVB @VDPRD,R1
       SRL  R1,>D
       JNE  DJUMP7
       RTWP
DJUMP5 LWPI DREGS
DJUMP6 CLR  R1
DJUMP7 SWPB R1
       MOVB R1,*R13
       SOCB @HEX20,R15
       RTWP
*// DSRLNK

*****************
**	
* VDP access
*

**
* VSBR - Read single byte at R0 into MSB R1
VSBR	
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	MOVB @>8800,R1
	B *R11

**
* VMBR - Read R2 bytes from VDP R0 to CPU R1	
* Destroys R1,R2
VMBR
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
VMBRLP
	MOVB @>8800,*R1+
	DEC R2
	JNE VMBRLP
	B *R11
	
**
* VSBW - Write single byte to R0 from MSB R1
* Destroys R0 (actually just oRs it)
VSBW
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	MOVB R1,@>8C00
	B *R11

**
* V2BW - Write two bytes to R0 from R1
* Destroys R0 (actually just oRs it)
V2BW
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	MOVB R1,@>8C00
	SWPB R1
	MOVB R1,@>8C00
	B *R11

**
* V2BR - Reads two bytes from R0 to R1
V2BR
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	MOVB @>8800,R1
	SWPB R1
	MOVB @>8800,R1
	SWPB R1
	B *R11

**
* VMBW - Write R2 bytes from CPU R1 to VDP R0
* Destroys R0,R1,R2
VMBW
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
VMBWLP
	MOVB *R1+,@>8C00
	DEC R2
	JNE VMBWLP
	B *R11
	
**
* VMBS - Set R2 bytes from R1 MSB to VDP R0
* Destroys R0,R1,R2
VMBS
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
VMBSLP
	MOVB R1,@>8C00
	DEC R2
	JNE VMBSLP
	B *R11

**
* VDPWA - Write address or register
VDPWA
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	B *R11  
	
**
* LOADRG - load regs list to VDP address, end on >0000 and 
* write >D0 (for sprites)
* address of table in R1 (destroyed)
LOADRG
LOADLP
	MOV *R1+,R0
	JEQ LDRDN
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	JMP LOADLP
LDRDN
	LI R1,>D000
	MOVB R1,@>8C00
	B *R11
	
****************************
* CHARSET - Load lower case charsets *
****************************
CHARSET
 MOV R11,R9   * Save our return spot
 LI R3,7

* 'lowercase' letters
 LI R0,>004A  * GPL vector address (not available for 99/4)
 LI R1,>4B00  * dest in VDP - must OR with >4000 for write
 LI R2,>001F  * how many chars
 BL @GPLVDP   * this function goes somewhere later in your ROM

* main set
MNSET
 LI R0,>0018  * GPL vector address
 LI R1,>4900  * dest in VDP - must OR with >4000 for write
 LI R2,>0040  * how many chars
 BL @GPLVDP   * this function goes somewhere later in your ROM
 B *R9        * RETURN TO CALLER

*****************
* GROM routines *
*****************
**
* GPLSET - Set GROM address
GPLSET
 MOVB R0,@>9C02
 SWPB R0
 MOVB R0,@>9C02
 B *R11

**
* GETGPL - Get a word from GPL
GETGPL
 MOVB @>9800,R0
 SWPB R0
 MOVB @>9800,R0
 SWPB R0
 B *R11

**
* GPLVDP - Copy R2 characters from a GPL copy function vectored at
* R0 to VDP R1. GPL vector must be a B or BR and
* the first actual instruction must be a DEST with an
* immediate operand. Set R3 to 6 for 99/4 (6 byte characters)
* or 7 for a 99/4A (7 byte characters)
GPLVDP
 MOV R11,R10    * save return address
 BL @GPLSET     * set GROM address
 BL @GETGPL     * Get branch instruction (not verified!)
 ANDI R0,>1FFF  * mask out instruction part
 AI R0,3        * skip instruction and destination
 BL @GPLSET     * set new GROM address
 BL @GETGPL     * get actual address of the table
 BL @GPLSET     * and set that GROM address - GROM is now ready!

 SWPB R1        * assume VDP is already prepared for write to save space
 MOVB R1,@>8C02
 SWPB R1
 MOVB R1,@>8C02 * VDP is now ready!

 CLR R0
LP8
 MOVB R0,@>8C00 * pad the top of the char with a space
 MOV R3,R0      * then copy 7 (or 6) bytes

LP9
 MOVB @>9800,@>8C00  * copy a byte (both sides autoincrement)
 DEC R0
 JNE LP9

 DEC R2         * next character
 JNE LP8

 B *R10
 
**
* BITMAP - Setup for normal bitmap mode
* returns with video off - set VDP R1 to E2 to enable (>81E2)
BITMAP
	MOV R11,@SAVE

* set display and disable sprites
	LI R1,BMREGS
	BL @LOADRG
	
* set up SIT - We load the standard 0-255, 3 times
	LI R0,>5800
	BL @VDPWA
	CLR R2
NQ# 
	CLR R1
LP# 
	MOVB R1,@>8C00
	AI R1,>0100
	CI R1,>0000
	JNE LP#
	INC R2
	CI R2,3
	JNE NQ#
	
	MOV @SAVE,R11
	B *R11
	
**
* HALFM - Setup for Half-Multicolor	
HALFM	
	MOV R11,@SAVE
	
* set display and disable sprites
	LI R1,HMREGS
	BL @LOADRG

* set up screen image table (not normal bitmap, each bank offset by 1 line)
	LI R0,>7800
	BL @VDPWA
	CLR R2
	CLR R1
	MOV R1,R3
NQH# 
	MOV R3,R1
LPH# 
	MOVB R1,@>8C00
	AI R1,>0100
	CB R1,R3
	JNE LPH#
	AI R3,>2000		* change start offset by 32
	INC R2
	CI R2,3
	JNE NQH#
	
	MOV @SAVE,R11
	B *R11
 
**
* KSCAN wrapper (always mode 5)
KSCAN
	LWPI >83E0	* GPLWS

* This quit test copied from the console ROM
	LI 12,>0024 		* Load CRU
	LDCR @>0012,3
	SRC 12,7				* delay
	LI 12,>0006
	STCR 5,8 				* Fetch CRU
	CZC @QUITK,5 		* QUIT key?
	JNE MENUKY
	B @REBOOT				* reboot if yes
	
	BL @RAND				* scramble random numbers

MENUKY
	LI R0,>0500
	MOVB R0,@>8374
	BL @>000E	* SCAN
	LWPI >8300	* my WS
	B *R11
	
**
* LOAD image to VRAM:
* R0 - VRAM address
* R1 - Image number (1-60 -- must be BCD! No hex!) TODO! NEEDS TO BE FILENAME
* R2 - (MSB) P, M or C 
LOAD
	MOV R11,@SAVE2		* save return address
	
	MOV R0,@PAB+2			* patch load address
	MOVB R2,@PAB+22		* patch filename last char
	MOV R1,R0
	ANDI R0,>00F0
	SRL R0,4
	AI R0,>0030
	SWPB R0
	ANDI R1,>000F
	AI R1,>0030
	SWPB R1
	MOVB R0,@PAB+16
	MOVB R1,@PAB+17		* patch filename number
	LI R0,>0500
	MOVB R0,@PAB			* patch opcode
	LI R0,PABADR
	LI R1,PAB
	LI R2,24
	BL @VMBW					* write the PAB
	LI R0,PABADR

	BLWP @DSRLNK
	DATA 8
	
	MOV @SAVE2,R11
	B *R11
	
**
* DELAY for DELTM seconds with both QUIT and Enter/Space detection
* does it internally for the sake of the F18A versions
DELAY
	MOV R11,@SAVE2
	LI R3,0
	MOV @DELTM,R1
TMLP
	AI R3,60					* one second in jiffies
	DEC R1
	JNE TMLP					* yeah, I could mult, but that takes more regs

DELLP	
* This quit test copied from the console ROM
	LI 12,>0024 			* Load CRU
	LDCR @>0012,3
	SRC 12,7					* delay
	LI 12,>0006
	STCR 5,8 					* Fetch CRU
	CZC @QUITK,5 			* QUIT key?
	JNE WAIT
	B @REBOOT					* reboot if yes
WAIT
	BL @KSCAN
	CLR R1
	MOVB @>8375,R1
	CI R1,>0F00				* FCTN-9 key?
	JNE WAIT2
	B @START					* restart if yes
WAIT2
	CI R1,>2000				* space key?
	JNE WAIT3
	LI R3,1						* countdown to 0
WAIT3	
	MOVB @>8802,R1		* check VDP status
	JGT WAIT2					* no interrupt yet
	JEQ WAIT2					* also no interrupt yet ;)
	MOV @INTFTN,R1
	JEQ WAIT4
	BL *R1
WAIT4	
	DEC R3
	JNE DELLP
	
	MOV @SAVE2,R11			* timed out
	B *R11
	
QUITK
	DATA >1100				* CRU value for QUIT

**
* REBOOT - restart the computer
*
REBOOT
	BL @RESTF18
	
* we've done all we can, the only thing left is that the VDP is still in enhanced mode (maybe)
	BLWP @>0000 			* Software reset	

**
* LOADPAL - Load an F18 Palette = pointer in R1	
LOADPAL	
	MOV R11,@SAVE
	
	LI R0,>AFC0       * Reg 47, value: 1100 0000, DPM = 1, AUTO INC = 1, palreg 0.       
  BL   @VDPWA       
	
	LI R2,32
	
PALLP
	MOVB *R1+,@>8C00
	DEC R2
	JNE PALLP
	
	LI R0,>AF00			   * Turn off the DPM mode
	MOV  @SAVE,R11
  B   @VDPWA       

**
* SETR1 - set VDP R1 and >83D4 for KSCAN - value in R0 MSB
SETR1
	MOV R11,@SAVE
	MOVB R0,@>83D4
	SWPB R0
	LI R1,>8100
	MOVB R1,R0
	BL @VDPWA
	MOV @SAVE,R11
	B *R11

**
* RESTF18 - Reset the palette and GPU on the F18 (no harm if not F18, 
* but expect registers to be messed up)	
RESTF18
	MOV R11,@SAVE2
	
* stop the GPU and then Reset (no harm if it's not F18)
	LI R0,>B800				* stop the GPU -- this does stop the GPU
	BL @VDPWA					* GPU will stop long before we're done

* the per-palette scanline swaps the palettes around, so force back
* to use palette 0.
	LI R0,>9800				* V24 = 0 (palette 0 for sprites and tiles)
	BL @VDPWA
	
RESTLP
	MOVB @>8802,R0		* get VDPST2 (or VDPST)
	JLT RESTLP				* if the MSB is set, wait (either RUNNING or FRAME_INT)
	
	LI R0,>8F00				* V15 = 0 - read SR0 again
	BL @VDPWA
	
* reload the default palette (no harm if it's not F18)
	MOV @SAVE2,R11
	LI R1,PALT
	BL @LOADPAL
	
* reset the F18A to defaults (except palette, requires 1.6)	
	LI R0,>B280				* VR2/50, value 10000000
	BL @VDPWA					* reset and lock F18A, or corrupt R2

* and lock it if it's still unlocked (pre 1.6)
	LI R0,>B900       * VR1/57, value 00000000
	BL @VDPWA          * write once (corrupts VDPR1)
	
	MOV @SAVE2,R11
	B *R11

**
* RAND - generate a 16-bit random number in R1 
RAND	
	MOV  @RNDSED,R1   * Get seed
	SRL  R1,1					* shift down
	JNC  RAND01				* jump if 1 not shifted out
	XOR  @RMASK,R1		* XOR the top half
RAND01	
	MOV  R1,@RNDSED   * Save this number for next time 
	B    *R11 
RMASK	
	DATA >B400				* mask for 16 bit random numbers
	
**
* TESTF18 - Check if F18A is present, return unlocked if so, 
* sets F18YES to FFFF (true) or 0000 (FALSE)
TESTF18
* This is not the way Matthew intended, but it's a tad easier
* We just check if the GPU is present by having it run a short
* program, instead of mucking around with status bits.
* May fail in the future, since it's not recommended, but if it
* does, we can't use the GPU anyway.
* F18A blind unlock code
	MOV R11,@SAVE
	
	LI R0,>B280				* VR2/50, value 10000000
	BL @VDPWA					* reset and lock F18A, or corrupt R2
	
	LI R0,>B91C       * VR1/57, value 00011100
	BL @VDPWA         * write once (corrupts VDPR1)
	BL @VDPWA         * write again (unlocks enhanced mode)

* If we are not on the F18, then R1 is screwed up now, that's okay
	LI R0,>1C00
	LI R1,GPUTEST
	LI R2,10
	BL @VMBW					* copy program
	
	LI R0,>1C10				* test address
	CLR R1
	BL @V2BW					* clear it
	
* Start the GPU program, pause, then check the result
	LI R0,>B61C				* MSB
	BL @VDPWA
	LI R0,>B700				* LSB and start
	BL @VDPWA
	NOP								* give it a moment - it's WAY faster than we are
	CLR @F18YES				* assume no F18A
	LI R0,>1C10
	BL @V2BR					* read the data
	CI R1,>1234
	JNE F18JMP
	SETO @F18YES			* yes, we have one
F18JMP
	MOV @SAVE,R11
	B *R11

GPUTEST
	DATA >0200,>1234		LI R0,>1234
	DATA >C800,>1C10		MOV R0,@>1C10
	DATA >0340					IDLE

* Per-scanline multicolor
* Binary data for the GPU program. Our assemblers aren't (well, weren't) smart enough to let
* us assemble code at one address but target another.	
PROG
  DATA >04C0         CLR R0         * copy from
  DATA >0201         LI R1,>1DFE    * copy to
  DATA >1DFE  
  DATA >0202         LI R2,171      * num bytes / 4 (first loop - 512 output bytes - 171 loops * 3 bytes = 513 bytes)
  DATA >00AB  
  DATA >06A0         BL @CPLP
  DATA >1B3C  
  DATA >0201         LI R1,>3800    * second part (4k)
  DATA >3800  
  DATA >0202         LI R2,1365     * num bytes / 4 (1365*3 bytes = 4095 - the one extra byte is in the first table)
  DATA >0555  
  DATA >06A0         BL @CPLP
  DATA >1B3C  
  DATA >100F         JMP RUN        * jump over the copy loop to go idle at the run block
  DATA >C0F0         MOV *R0+,R3    * copy word 0A BB
  DATA >C130         MOV *R0+,R4    * copy word 0C DD
  DATA >C143         MOV R3,R5      * setup work register
  DATA >0A45         SLA R5,4       * Shift up 'A'
  DATA >0245         ANDI R5,>F000  * mask
  DATA >F000  
  DATA >F144         SOCB R4,R5     * get 'C'
  DATA >DC45         MOVB R5,*R1+   * output 'AC'
  DATA >06C3         SWPB R3        * prepare 'BB'
  DATA >DC43         MOVB R3,*R1+
  DATA >06C4         SWPB R4        * prepare 'DD'
  DATA >DC44         MOVB R4,*R1+
  DATA >0602         DEC R2         * count down
  DATA >16F2         JNE CPLP       * continue till finished
  DATA >045B         B *R11         * return
  DATA >0340         IDLE           * go back to sleep - CPU must wake up us again
  DATA >04C5         CLR R5         * just make sure the LSB is blank
  DATA >0206         LI R6,>1FFF    * end of first block (unused byte)
  DATA >1FFF  
  DATA >0207         LI R7,>47FF    * end of second block (unused byte)
  DATA >47FF  
  DATA >0208         LI R8,>1DFE    * start of first block
  DATA >1DFE  
  DATA >0209         LI R9,>3800    * start of second block
  DATA >3800  
  DATA >020A         LI R10,>5000   * address of palette table
  DATA >5000  
  DATA >020C         LI R12,>F000   * a mask ('A')
  DATA >F000  
  DATA >020D         LI R13,>FF00   * compare value for scanline 255
  DATA >FF00  
  DATA >020E         LI R14,>7000   * address of scanline index
  DATA >7000  
  DATA >978D         CB R13,*R14    * check whether we are on line 255 yet (it repeats through line 262)
GIDLE1  
  DATA >16FE         JNE RUNLP
  DATA >C108         MOV R8,R4      * reset current palette table address
  DATA >C15E         MOV *R14,R5    * gets scanline and blanking bit
  DATA >2160         COC @BLANK,R5  * this will match immediately during vblank, that's okay :)
  DATA >1BD4  
  DATA >16FC         JNE SCANW1
  DATA >2AA0         XOR @PALOFF,R10 * Next palette register offset
  DATA >1BD2  
  DATA >22A0         COC @PALOFF,R10 * test the result equal to 5020? (too bad it wasn't 0/not 0)
  DATA >1BD2  
  DATA >1302         JEQ PAL2        * palette 2 is set
  DATA >04C0         CLR R0          * Palette 1 (sets sprites as well)
  DATA >1002         JMP PALCOM
  DATA >0200         LI R0,>0100     * second palette
  DATA >0100  
  DATA >D800         MOVB R0,@>6018  * VDP register >18
  DATA >6018  
  DATA >0203         LI R3,8         * 16 entries to copy / 2
  DATA >0008  
  DATA >C3CA         MOV R10,R15     * palette table address
  DATA >D034         MOVB *R4+,R0    * 'Ac'
  DATA >D074         MOVB *R4+,R1    * 'BB'
  DATA >D0B4         MOVB *R4+,R2    * 'DD'
  DATA >06C2         SWPB R2         * 00DD
  DATA >D080         MOVB R0,R2      * ACDD
  DATA >06C1         SWPB R1         * 00BB
  DATA >0940         SRL R0,4        * 0ACx
  DATA >D040         MOVB R0,R1      * 0ABB
  DATA >CFC1         MOV R1,*R15+    * write 0ABB    
  DATA >CFC2         MOV R2,*R15+    * write 0CDD
  DATA >8184         C R4,R6         * check for first table finished
  DATA >1602         JNE FIRSTB
  DATA >C109         MOV R9,R4       * yes, load second table
  DATA >1002         JMP NEXTCOL
  DATA >81C4         C R4,R7         * check for second table finished (split into 2 loops could avoid the double test)
  DATA >14DB         JHE RUNLP       * yes, wait for new frame
  DATA >0603         DEC R3
  DATA >16EE         JNE SCANL1      * loop around for more
  DATA >915E         CB *R14,R5      * wait for the scanline to change
  DATA >16DA         JNE SCANW1      * it changed, get to work immediately!
  DATA >10FD         JMP NEXTLIN     * not changed, keep waiting
  DATA >0020         DATA >0020      * XORd value for the alternate palette address
  DATA >0001         DATA >0001      * value of the blank bit (note it's always set in vblank)
PROGEND	

PALT
* default F18 palette values
	DATA >0000,>0000,>02C3,>05D6,>054F,>076F,>0D54,>04EF
	DATA >0F54,>0F76,>0DC3,>0ED6,>02B2,>0C5C,>0CCC,>0FFF
	
* registers for bitmap (and 5A00 is the address of the sprite table)
* background is transparent (the only color never redefined)
* PDT - >0000
* SIT - >1800
* SDT - >1800
* CT  - >2000
* SAL - >1B00
BMREGS DATA >81A0,>8002,>8206,>83ff,>8403,>8536,>8603,>8700,>5B00,>0000

* registers for 40-col text mode - EA settings
* PDT - >0800
* SIT - >0000
* SDT - >0000
* CT  - >0380
* SAL - >0300 (sprites are disabled but the function needs it anyway)
TXREGS DATA >81A0,>8000,>8200,>830E,>8401,>8506,>8600,>87F5,>4300,>0000

* registers for half-multicolor (sprites at >3B00)
HMREGS DATA >81A0,>8002,>820E,>83FF,>8403,>8576,>8707,>8700,>7B00,>0000

* Text strings
*       1234567890123456789012345678901234567890
TXTIMG
	TEXT ' Images found. Blank path to start.~'
	EVEN
TXTPTH
	TEXT 'Path: ~'
	EVEN
TXTCNT
	TEXT ' files found~'
	EVEN
TXTNOC
	TEXT 'No files found!~'
	EVEN
TXTDEL
	TEXT 'Delay (s): ~'
	EVEN
TXTRND
	TEXT 'Random? Y/N: ~'
	EVEN
TXTLP
	TEXT 'Loop? Y/N: ~'
	EVEN
TXTBEG
	TEXT 'Press Back to restart or Space to begin.~'
	EVEN
TXTERR
	TEXT 'I/O Error ~'
	EVEN

**
* print string r1 at r0
*
PRINT
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
PRLP
	CLR R2
	MOVB *r1+,r2
	ci r2,>7e00
	jeq prdone
	movb r2,@>8c00
	jmp prlp
	
prdone
  B *R11
	
**
* print number r1 at r0
* uses r0,r1,r2,r3
*
PRNUM
	ORI R0,>4000
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
prnlp
	clr r3
	mov r1,r2
	clr r1
	li r0,10000
	div r0,r1
	mov r1,r1
	jeq pn1
	seto r3
	ai r1,>3000
	movb r1,@>8c00
pn1
	clr r1
	li r0,>1000
	div r0,r1
	mov r3,r3
	jne pn2
	mov r1,r1
	jeq pn3
pn2
	seto r3
	ai r1,>3000
	movb r1,@>8c00

pn3
	clr r1
	li r0,>100
	div r0,r1
	mov r3,r3
	jne pn4
	mov r1,r1
	jeq pn5
pn4
	seto r3
	ai r1,>3000
	movb r1,@>8c00

pn5
	clr r1
	li r0,>10
	div r0,r1
	mov r3,r3
	jne pn6
	mov r1,r1
	jeq pn7
pn6
	seto r3
	ai r1,>3000
	movb r1,@>8c00

pn7
	ai r2,>3000
	movb r2,@>8c00
	B *R11
	
**
* input string to INPUTBUF at VDP r0
*
INNUM
	SETO @INPUTNUMS
	JMP INPUT2

INPUT
	CLR @INPUTNUMS
INPUT2
  MOV R11,R10
	ORI R0,>4000
	li r1,INPUTBUF
inlp
* wait for key release
	bl @kscan
	movb @>8375,r2
	ci r2,>ff00
	jne inlp
inlp2

	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>1e00
	movb r2,@>8c00		; cursor on
	
	bl @kscan
	movb @>8375,r2
	ci r2,>ff00
	jne inkey
	
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>2000
	movb r2,@>8c00		; cursor off
	
	bl @kscan
	movb @>8375,r2
	ci r2,>ff00
	jne inkey
	
	jmp inlp2
	
inkey
  ci r2,>0800
  jeq inbacksp
	ci r2,>0D00
	jeq inenter
	ci r2,>2000
	jl inlp
	ci r2,>5A00
	jh inlp

	MOV @INPUTNUMS,@INPUTNUMS		* limit to digits if called that way
	JEQ NOTNUMS
	ci r2,>3000
	jl inlp
	ci r2,>3900
	jh inlp

NOTNUMS
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	movb r2,@>8c00		; character out
	
	movb r2,*r1+
	inc r0
	ci r1,INPUTBUF+16			* need to leave two chars for the period and the tilde
	JL inlp
	dec r1
	dec r0
	jmp inlp
	
inenter
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>2000
	movb r2,@>8c00		; cursor off
	
	li r2,>2e7e				; write period and terminating tilde
	movb r2,*r1+
	swpb r2
	movb r2,*r1+

	B *R10
	
inbacksp
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>2000
	movb r2,@>8c00		; cursor off
	ci r1,INPUTBUF
	JEQ inlp
	dec r1
	dec r0
	jmp inlp
	

**
* input Y or N INPUTBUF at VDP r0
*
INYESNO
  MOV R11,R10
	ORI R0,>4000
	li r1,INPUTBUF
inynlp
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>1e00
	movb r2,@>8c00		; cursor on
	
	bl @kscan
	movb @>8375,r2
	ci r2,>5900
	jeq inyes
	ci r2,>7900
	jeq inyes
	ci r2,>4e00
	jeq inno
	ci r2,>6e00
	jeq inno
	
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	li r2,>2000
	movb r2,@>8c00		; cursor off
	
	bl @kscan
	movb @>8375,r2
	ci r2,>5900
	jeq inyes
	ci r2,>7900
	jeq inyes
	ci r2,>4e00
	jeq inno
	ci r2,>6e00
	jeq inno
	
	jmp inynlp
	
inyes
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	movb r2,@>8c00		; character out
	
	li r2,>597E				; write Y and terminating tilde
	movb r2,*r1+
	swpb r2
	movb r2,*r1+

	B *R10

inno
	SWPB R0
	MOVB R0,@>8C02
	SWPB R0
	MOVB R0,@>8C02
	movb r2,@>8c00		; character out
	
	li r2,>4E7E				; write Y and terminating tilde
	movb r2,*r1+
	swpb r2
	movb r2,*r1+

	B *R10

***
**
* Catalog - this is the most painful one
* R0 - address of count in device buffer (18 chars back to start)
*	R1 - index of the picture to return at (0 to search till end)
* R2 - VDP address to print a running count at, 0 for none
* Returns count found in R0
*
CATALOG
	MOV R11,R9

* save off the input data in R6,7,8
	MOV R0,R6				R6 - device buffer count
	MOV R1,r7				R7 - index to return at
	MOV R2,R8				R8 - VDP address for running count, or 0
	
* open in long filename mode
	MOV R6,R1
	AI R1,-18
	bl @wrapopenlong
	mov @dsrerr,r0
	jeq catopen
	
* if failed, open in short filename mode
	MOV R6,R1
	AI R1,-18
	bl @wrapopenshort
	mov @dsrerr,r0
	jne caterr
	
catopen
* we're in business, try to read!
* not sure where in VDP is good... just use >1000 for now
* everywhere is bad when an image is up ;)
	li r0,>1000
	mov r6,r1
	ai r1,-18
	bl @wrapread
	mov @dsrerr,r0
	jne caterr
	
* record zero is disk information, skip that and now we can start to loop
catloop
	li r0,>1000
	mov r6,r1
	ai r1,-18
	bl @wrapread
	mov @dsrerr,r0
	jne caterr
	
* got a record, copy it to CPU and then see if it's a _P type
	li r0,>1000
	li r1,recordbuf
	clr r2
	movb @PAB+5,r2		* get read bytes count from PAB copy
	swpb r2
	bl @vmbr					* read the record
	
* a file record looks as follows. Record 0 is the disk name
* record, and has a similar format but isn't something that
* we care about here.
*	0	Length of the name string
*	1-10	The filename itself (10 characters, may be shorter if desired, may be longer for LFN)
*	11-19	file type as a float (5 or -5 is program)
*	20-28	number of sectors as a float (include FDR)
*	29-37	record length as a float

* first make sure it's a program type, as that's all we read
* we cheat on the record type - the first 3 bytes will be
* 08 40 05 for '5' and 08 bf fb for '-5' (the rest are 0)
* but, the filename end is arbitrary, so we have to find that
	clr r0
	movb @recordbuf,r0
	swpb r0
	ai r0,recordbuf				* end of filename (even if corrupt, it's still in the buffer)
	inc r0								* one past - should be an 8
	clr r1
	movb *r0+,r1
	ci r1,>0800				
	jne caterr						* bad record, close and move on
	
	movb *r0+,r1
	swpb r1
	movb *r0+,r1					* get number, either
	ci r0,>0540						* PROGRAM file
	jeq gotprog
	ci r0,>fbbf						* protected PROGRAM file
	jeq gotprog
	
* don't care about this file, so loop around
	jmp catloop

* got a program type file, so we need to check if it's an _P (that's all we count)	
* r0 is already pointing after the filename, so we can backup 5 to check
gotprog
	ai r0,-5
	movb *r0+,r1
	swpb r1
	movb *r0+,r1					* last two chars of filename (reversed)
	ci r0,>505F						* P_ (remember, it's reversed)
	jne catloop						* next record if not our style
	
* now we have found a file we want to consider, play with the counters
	inc *r6								* increment counter in buffer
	mov r8,r0
	jeq catnoupdate
	mov *r6,r1						* going to notify on the screen
	bl @prnum
catnoupdate
	c *r6,r7							* are we done?
	jne catloop						* nope
	
* we are done, so copy the return value to r0
catreturn
	MOV R6,R1
	AI R1,-18
	bl @wrapclose					* on EOF it's supposed to auto-close, but won't hurt
*												* to be explicit
	mov *r6,r0
	B *r9
	
* a DSR error occurred. Note that end of file is not an error here. ;)
caterr
	clr r0
	movb @dsrerr,r0
	ci r0,>0500
	jeq catreturn					* end of file is okay, close and go home
	
	clr *r6								* no files on corrupt media, please!
	
	mov r8,r0							* check if we're reporting to the user
	jeq catreturn					* nope, so no way to say anything happened

* just tell the user what the error we saw was
	li r1,TXTERR
	bl @print
	mov @dsrerr,r1
	andi r1,>ff00
	swpb r1
	bl @prnlp							* don't change VDP address

	jmp catreturn					* and back to caller

****************************
* HERE WE GO - we also loop through this point
START
	LWPI >8300
	BL @RESTF18			* reset the F18 if present and active
	LI R1,TXREGS
	BL @LOADRG			* set text mode
	BL @CHARSET			* load character set from GROM
	LI R0,>F000
	BL @SETR1
	
* Check random seed (it can't be zero!)
	MOV @RNDSED,R0
	JNE CHKVDP
	MOV @>83C0,@RNDSED
	JNE CHKVDP
	INC @RNDSED
CHKVDP	
	
* Check VDR DSR space
	MOV @VDPBAD,R0
	JNE STREST
* it's okay, so make a copy of it
	BL @FILES				* make sure only 1 file
	LI R0,>3BDC
	LI R1,DSRBUF
	LI R2,1060
	BL @VMBR
	JMP STOK
STREST	
* It's bad, restore it
	LI R0,>3BDC
	LI R1,DSRBUF
	LI R2,1060
	BL @VMBW
	CLR @VDPBAD
STOK

	CLR @INTFTN			* remove any old interrupt callback
	CLR @ONESHOT		* Clear one-shot random mode

* clear the screen
	CLR R0
	LI R1,>2000
	LI R2,960
	BL @VMBS

* clear the data
	li r0,entries
	li r2,262
clrlp
	clr *r0+
	dect r2
	jne clrlp
	clr @totcnt
	
* R13 will be a counter for the entry index
	li r13,-1

* Program should start by asking for a device name. It then catalogs
* that device, and counts how many pics are on it, saving and displaying the
* count. It then asks again until you enter a blank entry.
PATHLP
	inc r13									* next entry
* print 'x Images Found'
	mov @totcnt,r1
	li r0,2
	bl @prnum
	li r1,txtimg
	bl @prlp
	
* print 'Path' prompt
	mov r13,r0
	li r1,40
	mpy r1,r0		; result in r0,r1
	mov r1,r0
	ai r0,82
	li r1,txtpth
	bl @print
	
* get the user's input - r1 gets ending address
* (start address is INPUTBUF)
	ai r0,6
	bl @input
	mov r0,r4				; save cursor address
	
	ci r1,inputbuf
	jeq endinput
	
* copy the input to the current input buffer
	mov r13,r2
	li r0,20
	mpy r0,r2
	mov r3,r2
	ai r2,entries
	li r0,inputbuf
incplp
	movb *r0+,*r2+
	c r0,r1
	jne incplp
	
* clear the count, then ask the catalog function to enumerate the drive
	mov r13,r2
	li r0,20
	mpy r0,r2
	ai r3,entries+18
	clr *r3
	mov r3,r0				; address of count for device buffer
	clr r1					; index of the picture we want (0-count them all)
	mov r4,r2				; VDP address to write count of found images
	inc r2          ; plus 1 for spacing
	bl @catalog			; go do it
	a r0,@totcnt		; update the total (no effect if it's zero)
	mov r0,r0				; did we find any files?
	jeq nofiles
	inc r13					; save the record
nofiles
	mov r0,r1				; number
	mov r2,r0				; screen address
	bl @prnum
	li r1,txtcnt
	bl @prlp

	ci r13,12				; at the end?
	jeq endinput

	jmp pathlp
	
endinput	
* Next it asks 'delay (s)' and saves that in DELTM (maybe limit to 99?)
	mov r13,r0
	li r1,40
	mpy r1,r0		; result in r0,r1
	mov r1,r0
	ai r0,162
	li r1,txtdel
	bl @print
	
* get the user's input - r1 gets ending address
* (start address is INPUTBUF)
	ai r0,11
	bl @innum
* convert it to a number
	clr @DELTM
	ci r1,INPUTBUF
	JEQ EIDONE
	li r0,1
eilp1	
	dec r1
	movb *r1,r2
	srl r2,8
	ai r2,->0030
	mpy r0,r2			* multiply digit by power of ten
	a r3,@DELTM
	
	li r2,10
	mpy r0,r2			* make next power of ten
	mov r3,r0
	ci r1,INPUTBUF
	JNE eilp1
EIDONE

* Then it asks 'random? y/n' and saves that
	mov r13,r0
	li r1,40
	mpy r1,r0		; result in r0,r1
	mov r1,r0
	ai r0,202
	li r1,txtrnd
	bl @print
	
* get the user's input - guarantee uppercase
* (start address is INPUTBUF)
	ai r0,13
	bl @inyesno
	
	clr @random
	clr r0
	movb @inputbuf,r0
	ci r0,>5900
	jne notrnd
	seto @random
notrnd

* and 'loop? y/n'
	mov r13,r0
	li r1,40
	mpy r1,r0		; result in r0,r1
	mov r1,r0
	ai r0,242
	li r1,txtlp
	bl @print
	
* get the user's input - guarantee uppercase
* (start address is INPUTBUF)
	ai r0,11
	bl @inyesno
	
	clr @loop
	clr r0
	movb @inputbuf,r0
	ci r0,>5900
	jne notloop
	seto @loop
notloop

*** TODO: infinite loop for debugging
	jmp notloop
	
*-------------------------------------------------------------------------
*(here)

* Then it starts. We have a list of devices and how many files are
* on each so that we can work out which device to access for each file
* (this way it works both sequential and random). On the device, the catalog
* is scanned to find the file by count (remember to count only _P files),
* and then the file is loaded and displayed.
* In memory, we maintain a simple list of 18 character device names and
* a count of files on that device. A blank character device name will
* indicate the last entry in the list, and we'll have a max of say 12 devices,
* it's only 20 bytes per entry. (With 12 I don't need to scroll the screen).
* Detection of filetype is dynamic and based on the _M file length. TIAP
* loader needs to also recognize a file with no color table, and load a
* default one for that.
*
* 47 Images found. Enter blank path to start.
*
* Path: WSD1.SUBDIR1 - 17 files found
* Path: DSK1 - 8 files found
* Path: HDX1 - 22 files found
* Path: CLOCK - No files found!
* Path:
*
* Delay (s): 10
* Random? Y/N: Yes
* Loop? Y/N: Yes
*
* Press Back to restart or Space to begin
*

** dummy labels
SETDSK
BCDINC
MULTIC
BCD
TABLE
		
MENULP
	BL @KSCAN
	CLR R1
	MOVB @>8375,R1
	CI R1,>3100
	JNE M1
	B @MODE1
M1
	CI R1,>3200
	JNE M2
	B @MODE2
M2
	CI R1,>3300
	JNE M3
	B @MODE3
M3
	CI R1,>3400
	JNE M4
	B @MODE4
M4	
	CI R1,>3500
	JNE M5
	B @MODE5
M5	
	CI R1,>3600
	JNE M6
	B @MODE6
M6	
	CI R1,>3700
	JNE M7
	B @MODE7
	
M7
	CI R1,>2500			* '%' = Shift-5
	JNE M8
	B @MODE5O
	
M8
	CI R1,>5E00			* '^' = shift-6
	JNE M9
	B @MODE6O
	
M9
	CI R1,>2600			* '&' = shift-7
	JNE MENULP
	B @MODE7O
	
* 1) for 9918A Bitmap                   
MODE1
	BL @BITMAP			* Set bitmap mode
	MOV @COUNT1,R15		* image number! 20 images per disk
	LI R14,1			* base disk number
	
MODE1L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)

	BL @SETDSK
	CLR R0
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	LI R0,>2000
	MOV R15,R1
	LI R2,>4300			* 'C'
	BL @LOAD
	
	LI R0,>E200
	BL @SETR1			* enable display
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT1		* save it
	CI R15,>0061		* are we done?
	JNE MODE1L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT1
	B @START			* yes

* 2) for 9918 Multicolor                
MODE2
	BL @MULTIC			* Set multicolor mode
	MOV @COUNT2,R15		* image number! 20 images per disk
	LI R14,4			* base disk number
	
MODE2L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)

	BL @SETDSK
	LI R0,>0800
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	LI R0,>EA00
	BL @SETR1			* enable display
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT2		* save it
	CI R15,>0061		* are we done?
	JNE MODE2L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT2
	B @START			* yes

* 3) for 9918 dual-multicolor (flicker) 
MODE3
	BL @MULTIC			* Set multicolor mode
	MOV @COUNT3,R15		* image number! 20 images per disk
	LI R14,7			* base disk number
	
MODE3L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)

	BL @SETDSK
	LI R0,>0800
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	LI R0,>1000
	MOV R15,R1
	LI R2,>4300			* 'C'
	BL @LOAD
	
	LI R1,MODE3I
	MOV R1,@INTFTN

	LI R0,>EA00
	BL @SETR1			* enable display
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT3		* save it
	CI R15,>0061		* are we done?
	JNE MODE3L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT3
	B @START			* yes
	
MODE3I
	MOV @FLAG,R0
	JNE INTR32
	SETO @FLAG
	LI R0,>8402
	B @VDPWA		* let it return
INTR32
	CLR @FLAG
	LI R0,>8401
	B @VDPWA		* let it return

* 4) for 9918A half-multicolor (flicker)
MODE4
	BL @HALFM			* Set half-multicolor mode
	MOV @COUNT4,R15		* image number! 20 images per disk
	LI R14,10			* base disk number
	
MODE4L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)

	BL @SETDSK
	CLR R0
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	LI R0,>2000
	MOV R15,R1
	LI R2,>4300			* 'C'
	BL @LOAD
	
	LI R0,>1800
	MOV R15,R1
	LI R2,>4D00			* 'M'
	BL @LOAD
	
	LI R1,MODE4I
	MOV R1,@INTFTN

* We don't enable the display here because the interrupt routine toggles VDP R1 anyway
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT4		* save it
	CI R15,>0061		* are we done?
	JNE MODE4L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT4
	B @START			* yes
	
MODE4I
	MOV @FLAG,R0
	JNE INTR42
	SETO @FLAG
	
	MOV R11,R1
	LI R0,>8000
	BL @VDPWA
	MOV R1,R11
	LI R0,>81E8
	B @VDPWA
		
INTR42
	CLR @FLAG
	
	MOV R11,R1
	LI R0,>8002
	BL @VDPWA
	MOV R1,R11
	LI R0,>81E0
	B @VDPWA
	
* 5) for F18A paletted bitmap           
MODE5
	LI R0,START
	MOV R0,@SAVE2		* on failure, go back to start
	BL @TESTF18			* make sure we HAVE an F18 (hold shift to skip)
	
MODE5O
	BL @BITMAP			* Set bitmap mode
	MOV @COUNT5,R15		* image number! 20 images per disk
	LI R14,13			* base disk number

MODE5L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)

	BL @SETDSK
	CLR R0
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	LI R0,>2000
	MOV R15,R1
	LI R2,>4300			* 'C'
	BL @LOAD
	
	LI R0,>1C00
	MOV R15,R1
	LI R2,>4D00			* 'M'
	BL @LOAD
	
	LI R0,>1C00
	LI R1,PALBUF
	LI R2,32
	BL @VMBR			* copy palette to CPU RAM
	
	LI R1,PALBUF
	BL @LOADPAL			* load palette to F18
	
	LI R0,>E200
	BL @SETR1			* enable display
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT5		* save it
	CI R15,>0061		* are we done?
	JNE MODE5L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT5
	B @START			* yes

* 6) for F18A scanline palette bitmap   
MODE6
	LI R0,START
	MOV R0,@SAVE2		* on failure, go back to start
	BL @TESTF18			* make sure we HAVE an F18 (hold shift to skip)
	
MODE6O
	BL @BITMAP			* Set bitmap mode
	MOV @COUNT6,R15		* image number! 20 images per disk
	LI R14,16			* base disk number

MODE6L
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)
	LI R0,>B800			* stop the GPU
	BL @VDPWA
	
	MOV @VDPBAD,R0		* is VDP DSR space corrupt?
	JEQ MODE6V
	
	LI R0,>3BDC
	LI R1,DSRBUF
	LI R2,1060
	BL @VMBW			* yes, restore it
	
MODE6V
	
* there's a small problem here that we destroy the disk buffers with our
* image data (there MAY be a way to arrange it all to fit, but it's tight)
* we have to first load EVERYTHING, then backup the DSR, then we can
* destroy the data there. This method doesn't allow much concurrency.
	BL @SETDSK

* first load the pattern table and back up in CPU RAM
	CLR R0
	MOV R15,R1
	LI R2,>5000			* 'P'
	BL @LOAD
	
	CLR R0
	LI R1,PATBUF
	LI R2,6144
	BL @VMBR

* now load the color table into place
	LI R0,>2000
	MOV R15,R1
	LI R2,>4300			* 'C'
	BL @LOAD

* finally, load the palette data (in the pattern table address)		
	CLR R0
	MOV R15,R1
	LI R2,>4D00			* 'M'
	BL @LOAD
	
* Get the GPU code into VDP as well
	LI R0,PROGLD		* load address of code
	LI R1,PROG			* code itself
	LI R2,PROGEND-PROG	* number of bytes
	BL @VMBW
	
* Now start it running
	LI R0,>B61B			* MSB
	BL @VDPWA
	LI R0,>B720			* LSB
	BL @VDPWA
	
* GPU is now working on the palette. We'll copy in the
* pattern table at the same time. Although it's the same
* buffer, the GPU is WAY faster and should be way ahead
* of us by the time we get to the first word.
	CLR R0
	LI R1,PATBUF
	LI R2,6144
	BL @VMBW
	
* Set the special flag for the main code to restore
* the VDP buffer!
	SETO @VDPBAD

* GPU should be idling, so just wake it up
	LI R0,>B801
	BL @VDPWA
		
	LI R0,>E200
	BL @SETR1			* enable display
	
	BL @DELAY			* wait 10 seconds (with return to menu)
	
	BL @BCDINC			* next image
	MOV R15,@COUNT6		* save it
	CI R15,>0061		* are we done?
	JNE MODE6L			* no!
	
	LI R15,>0001
	MOV R15,@COUNT6
	B @START			* yes

* 7) for continuous random              
MODE7
* WE OWN R7! Muhaha! We use it to store the max picture index, based on F18 support
	LI R7,240			* assume no F18A - 240 pics available
	LI R0,MODE72
	MOV R0,@SAVE2		* jump over change if it's not there
	BL @TESTF18

MODE7O
	LI R7,360			* it IS real!! - 360 pics available

* Here we just run forever - we pick a random image
MODE72
	LI R0,>81A0
	BL @VDPWA			* clear display (no need for SetR1 here)
	BL @RESTF18			* and reset the F18

	MOV @VDPBAD,R0		* is VDP DSR space corrupt?
	JEQ MODE7V
	
	LI R0,>3BDC
	LI R1,DSRBUF
	LI R2,1060
	BL @VMBW			* yes, restore it
	CLR @VDPBAD

MODE7V
	CLR @INTFTN			* remove any old interrupt function
	BL @RAND			* get randomish number into R1
	CLR R0				* extend to 32-bits
	DIV R7,R0			* divide by the number of desired pics, R1 gets remainder
	
* The picture number is in R1, so now divide again to get the group and file number
* the groups themselves deal with the actual disk division
	LI R2,60			* sixty pics per group
	CLR R0				* just picture number
	DIV R2,R0			* R0 gets group, R1 gets image in that group
	MOVB @BCD(R1),R1	* Hah! Hacky lookup from hex->BCD
	SRL R1,8
	MOV R0,R2			* R0 can't be an index register
	SLA R2,1			* multiply by 2 for word index
	MOV R1,@COUNT1(R2)	* Store image number in the appropriate3 group
	MOV @TABLE(R2),R0	* get jump address
	SETO @ONESHOT		* flag a one-shot load
	B *R0				* go do it! they will come back here

SLAST

* Empty buffers that are not saved with the program
SAVE  BSS 2	
SAVE2 BSS 2
FLAG  BSS 2
INPUTNUMS BSS 2
INTFTN BSS 2
ONESHOT BSS 2
RNDSED BSS 2
PALBUF BSS 32
PATBUF BSS 6144
DSRBUF BSS 1060
DELTM  BSS 2
RANDOM BSS 2
LOOP   BSS 2
DREGS  BSS 32
NAMBUF BSS 8
F18YES BSS 2
INPUTBUF BSS 18
TOTCNT BSS 2
PAB BSS 10
RECLEN BSS 2					* record length from open - note: BYTE!
RECMODE BSS 2					* record mode from open - note: BYTE!
DSRREC BSS 2					* record index for PAB
DSRERR BSS 2					* error byte from PAB
ENTRIES BSS 262				* 12 entries + 2 bytes so I can have some zero bytes to NUL terminate
RECORDBUF BSS 256

	END

